import { InvoiceStatus, PaymentMethod, CreditNoteReason, CreditNoteStatus } from '@/types'\n\nexport const financialUtils = {\n  // Invoice utilities\n  getInvoiceStatusDisplayName(status: InvoiceStatus): string {\n    const statusNames: Record<InvoiceStatus, string> = {\n      draft: 'Draft',\n      sent: 'Sent',\n      paid: 'Paid',\n      overdue: 'Overdue',\n      cancelled: 'Cancelled'\n    }\n    return statusNames[status]\n  },\n\n  getInvoiceStatusColor(status: InvoiceStatus): string {\n    const statusColors: Record<InvoiceStatus, string> = {\n      draft: 'bg-gray-100 text-gray-800',\n      sent: 'bg-blue-100 text-blue-800',\n      paid: 'bg-green-100 text-green-800',\n      overdue: 'bg-red-100 text-red-800',\n      cancelled: 'bg-gray-100 text-gray-800'\n    }\n    return statusColors[status]\n  },\n\n  getAllInvoiceStatuses(): { value: InvoiceStatus; label: string }[] {\n    return [\n      { value: 'draft', label: 'Draft' },\n      { value: 'sent', label: 'Sent' },\n      { value: 'paid', label: 'Paid' },\n      { value: 'overdue', label: 'Overdue' },\n      { value: 'cancelled', label: 'Cancelled' }\n    ]\n  },\n\n  // Payment method utilities\n  getPaymentMethodDisplayName(method: PaymentMethod): string {\n    const methodNames: Record<PaymentMethod, string> = {\n      cash: 'Cash',\n      bank_transfer: 'Bank Transfer',\n      credit_card: 'Credit Card',\n      debit_card: 'Debit Card',\n      check: 'Check',\n      crypto: 'Cryptocurrency',\n      other: 'Other'\n    }\n    return methodNames[method]\n  },\n\n  getAllPaymentMethods(): { value: PaymentMethod; label: string }[] {\n    return [\n      { value: 'bank_transfer', label: 'Bank Transfer' },\n      { value: 'credit_card', label: 'Credit Card' },\n      { value: 'debit_card', label: 'Debit Card' },\n      { value: 'cash', label: 'Cash' },\n      { value: 'check', label: 'Check' },\n      { value: 'crypto', label: 'Cryptocurrency' },\n      { value: 'other', label: 'Other' }\n    ]\n  },\n\n  // Credit note utilities\n  getCreditNoteReasonDisplayName(reason: CreditNoteReason): string {\n    const reasonNames: Record<CreditNoteReason, string> = {\n      return: 'Return',\n      discount: 'Discount',\n      error: 'Error Correction',\n      cancellation: 'Cancellation',\n      other: 'Other'\n    }\n    return reasonNames[reason]\n  },\n\n  getCreditNoteStatusDisplayName(status: CreditNoteStatus): string {\n    const statusNames: Record<CreditNoteStatus, string> = {\n      draft: 'Draft',\n      issued: 'Issued',\n      applied: 'Applied'\n    }\n    return statusNames[status]\n  },\n\n  getCreditNoteStatusColor(status: CreditNoteStatus): string {\n    const statusColors: Record<CreditNoteStatus, string> = {\n      draft: 'bg-gray-100 text-gray-800',\n      issued: 'bg-blue-100 text-blue-800',\n      applied: 'bg-green-100 text-green-800'\n    }\n    return statusColors[status]\n  },\n\n  getAllCreditNoteReasons(): { value: CreditNoteReason; label: string }[] {\n    return [\n      { value: 'return', label: 'Return' },\n      { value: 'discount', label: 'Discount' },\n      { value: 'error', label: 'Error Correction' },\n      { value: 'cancellation', label: 'Cancellation' },\n      { value: 'other', label: 'Other' }\n    ]\n  },\n\n  // Number generation\n  generateInvoiceNumber(): string {\n    const year = new Date().getFullYear()\n    const month = (new Date().getMonth() + 1).toString().padStart(2, '0')\n    const randomNum = Math.floor(Math.random() * 9999).toString().padStart(4, '0')\n    return `G1-INV-${year}${month}-${randomNum}`\n  },\n\n  generateReceiptNumber(): string {\n    const year = new Date().getFullYear()\n    const month = (new Date().getMonth() + 1).toString().padStart(2, '0')\n    const randomNum = Math.floor(Math.random() * 9999).toString().padStart(4, '0')\n    return `G1-RCP-${year}${month}-${randomNum}`\n  },\n\n  generateCreditNoteNumber(): string {\n    const year = new Date().getFullYear()\n    const month = (new Date().getMonth() + 1).toString().padStart(2, '0')\n    const randomNum = Math.floor(Math.random() * 9999).toString().padStart(4, '0')\n    return `G1-CN-${year}${month}-${randomNum}`\n  },\n\n  // Calculation utilities\n  calculateInvoiceTotal(items: any[], taxRate: number = 0, discountAmount: number = 0): number {\n    const subtotal = items.reduce((sum, item) => sum + (item.quantity * item.unit_price), 0)\n    const taxAmount = subtotal * taxRate\n    return Math.max(0, subtotal + taxAmount - discountAmount)\n  },\n\n  calculateTaxAmount(subtotal: number, taxRate: number): number {\n    return subtotal * taxRate\n  },\n\n  calculateSubtotal(items: any[]): number {\n    return items.reduce((sum, item) => sum + (item.quantity * item.unit_price), 0)\n  },\n\n  // Validation utilities\n  validateInvoiceItems(items: any[]): string[] {\n    const errors: string[] = []\n    \n    if (!items || items.length === 0) {\n      errors.push('At least one item is required')\n      return errors\n    }\n    \n    items.forEach((item, index) => {\n      if (!item.description || item.description.trim().length === 0) {\n        errors.push(`Item ${index + 1}: Description is required`)\n      }\n      \n      if (!item.quantity || item.quantity <= 0) {\n        errors.push(`Item ${index + 1}: Quantity must be greater than 0`)\n      }\n      \n      if (item.unit_price === undefined || item.unit_price < 0) {\n        errors.push(`Item ${index + 1}: Unit price cannot be negative`)\n      }\n      \n      const expectedTotal = (item.quantity || 0) * (item.unit_price || 0)\n      if (Math.abs((item.total || 0) - expectedTotal) > 0.01) {\n        errors.push(`Item ${index + 1}: Total should be ${expectedTotal.toFixed(2)}`)\n      }\n    })\n    \n    return errors\n  },\n\n  // Date utilities\n  calculateDueDate(issueDate: string, paymentTerms: number = 30): string {\n    const issue = new Date(issueDate)\n    const due = new Date(issue)\n    due.setDate(due.getDate() + paymentTerms)\n    return due.toISOString()\n  },\n\n  isOverdue(dueDate: string): boolean {\n    return new Date(dueDate) < new Date()\n  },\n\n  getDaysOverdue(dueDate: string): number {\n    const due = new Date(dueDate)\n    const now = new Date()\n    const diffTime = now.getTime() - due.getTime()\n    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24))\n    return Math.max(0, diffDays)\n  },\n\n  // Currency utilities\n  getSupportedCurrencies(): { code: string; name: string; symbol: string }[] {\n    return [\n      { code: 'USD', name: 'US Dollar', symbol: '$' },\n      { code: 'EUR', name: 'Euro', symbol: '‚Ç¨' },\n      { code: 'GBP', name: 'British Pound', symbol: '¬£' },\n      { code: 'CHF', name: 'Swiss Franc', symbol: 'CHF' },\n      { code: 'JPY', name: 'Japanese Yen', symbol: '¬•' },\n      { code: 'CAD', name: 'Canadian Dollar', symbol: 'C$' },\n      { code: 'AUD', name: 'Australian Dollar', symbol: 'A$' },\n      { code: 'SGD', name: 'Singapore Dollar', symbol: 'S$' },\n      { code: 'HKD', name: 'Hong Kong Dollar', symbol: 'HK$' },\n      { code: 'AED', name: 'UAE Dirham', symbol: 'AED' }\n    ]\n  },\n\n  // Financial reporting utilities\n  calculateFinancialSummary(invoices: any[], receipts: any[], creditNotes: any[]) {\n    const totalInvoiced = invoices.reduce((sum, inv) => sum + inv.amount, 0)\n    const totalPaid = receipts.reduce((sum, rec) => sum + rec.amount, 0)\n    const totalCredited = creditNotes.reduce((sum, cn) => sum + cn.amount, 0)\n    const outstanding = totalInvoiced - totalPaid - totalCredited\n    \n    return {\n      totalInvoiced,\n      totalPaid,\n      totalCredited,\n      outstanding,\n      paidPercentage: totalInvoiced > 0 ? (totalPaid / totalInvoiced) * 100 : 0\n    }\n  },\n\n  // Status transition utilities\n  canTransitionInvoiceStatus(currentStatus: InvoiceStatus, newStatus: InvoiceStatus): boolean {\n    const allowedTransitions: Record<InvoiceStatus, InvoiceStatus[]> = {\n      draft: ['sent', 'cancelled'],\n      sent: ['paid', 'overdue', 'cancelled'],\n      paid: [], // Final state\n      overdue: ['paid', 'cancelled'],\n      cancelled: [] // Final state\n    }\n    \n    return allowedTransitions[currentStatus]?.includes(newStatus) || false\n  },\n\n  getInvoiceIcon(status: InvoiceStatus): string {\n    const iconMap: Record<InvoiceStatus, string> = {\n      draft: 'üìù',\n      sent: 'üì§',\n      paid: '‚úÖ',\n      overdue: '‚ö†Ô∏è',\n      cancelled: '‚ùå'\n    }\n    return iconMap[status] || 'üìÑ'\n  },\n\n  formatInvoiceReference(invoiceNumber: string, clientName: string): string {\n    return `${invoiceNumber} - ${clientName}`\n  }\n}"