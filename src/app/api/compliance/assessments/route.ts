import { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@/lib/supabase/server'\nimport { authServer } from '@/lib/auth'\nimport { complianceAssessmentSchema } from '@/lib/validations/kyc'\nimport { kycUtils } from '@/lib/kyc-utils'\n\nexport async function GET(request: NextRequest) {\n  try {\n    // Require permission to view compliance assessments\n    const user = await authServer.requireRole(['admin', 'compliance', 'finance', 'operations'])\n    \n    const supabase = createClient()\n    const { searchParams } = new URL(request.url)\n    \n    const page = parseInt(searchParams.get('page') || '1')\n    const limit = parseInt(searchParams.get('limit') || '10')\n    const clientId = searchParams.get('client_id')\n    const riskLevel = searchParams.get('risk_level')\n    const assessmentType = searchParams.get('assessment_type')\n    \n    const offset = (page - 1) * limit\n    \n    let query = supabase\n      .from('compliance_assessments')\n      .select(`\n        *,\n        client:clients(\n          id,\n          name,\n          email,\n          type,\n          country,\n          compliance_status\n        ),\n        assessed_by_user:user_profiles!assessed_by(\n          id,\n          name\n        )\n      `, { count: 'exact' })\n      .order('created_at', { ascending: false })\n    \n    // Apply filters\n    if (clientId) {\n      query = query.eq('client_id', clientId)\n    }\n    \n    if (riskLevel) {\n      query = query.eq('risk_level', riskLevel)\n    }\n    \n    if (assessmentType) {\n      query = query.eq('assessment_type', assessmentType)\n    }\n    \n    const { data, error, count } = await query\n      .range(offset, offset + limit - 1)\n    \n    if (error) {\n      return NextResponse.json({ error: error.message }, { status: 400 })\n    }\n    \n    return NextResponse.json({\n      data,\n      count,\n      page,\n      limit,\n      total_pages: Math.ceil((count || 0) / limit)\n    })\n  } catch (error) {\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Require compliance permission to create assessments\n    const user = await authServer.requireRole(['admin', 'compliance'])\n    \n    const body = await request.json()\n    \n    // Validate request body\n    const validatedData = complianceAssessmentSchema.parse({\n      ...body,\n      assessed_by: user.id\n    })\n    \n    const supabase = createClient()\n    \n    // Verify client exists\n    const { data: client, error: clientError } = await supabase\n      .from('clients')\n      .select('id, name, type, country')\n      .eq('id', validatedData.client_id)\n      .single()\n    \n    if (clientError || !client) {\n      return NextResponse.json({ error: 'Client not found' }, { status: 400 })\n    }\n    \n    // Validate risk factors\n    const totalWeight = validatedData.risk_factors.reduce((sum, factor) => sum + factor.weight, 0)\n    if (Math.abs(totalWeight - 1) > 0.01) {\n      return NextResponse.json(\n        { error: 'Risk factor weights must sum to 1.0' },\n        { status: 400 }\n      )\n    }\n    \n    // Verify calculated risk score matches\n    const calculatedScore = kycUtils.calculateRiskScore(validatedData.risk_factors)\n    if (Math.abs(calculatedScore - validatedData.overall_risk_score) > 5) {\n      return NextResponse.json(\n        { error: 'Calculated risk score does not match provided score' },\n        { status: 400 }\n      )\n    }\n    \n    // Verify risk level matches score\n    const expectedRiskLevel = kycUtils.getRiskLevelFromScore(validatedData.overall_risk_score)\n    if (expectedRiskLevel !== validatedData.risk_level) {\n      return NextResponse.json(\n        { error: `Risk level should be '${expectedRiskLevel}' for score ${validatedData.overall_risk_score}` },\n        { status: 400 }\n      )\n    }\n    \n    // Create assessment\n    const { data, error } = await supabase\n      .from('compliance_assessments')\n      .insert({\n        client_id: validatedData.client_id,\n        assessment_type: validatedData.assessment_type,\n        risk_factors: validatedData.risk_factors,\n        overall_risk_score: validatedData.overall_risk_score,\n        risk_level: validatedData.risk_level,\n        recommendations: validatedData.recommendations,\n        next_review_date: validatedData.next_review_date,\n        assessed_by: validatedData.assessed_by,\n        notes: validatedData.notes,\n        metadata: validatedData.metadata || {}\n      })\n      .select(`\n        *,\n        client:clients(\n          id,\n          name,\n          email,\n          type\n        ),\n        assessed_by_user:user_profiles!assessed_by(\n          id,\n          name\n        )\n      `)\n      .single()\n    \n    if (error) {\n      return NextResponse.json({ error: error.message }, { status: 400 })\n    }\n    \n    // Update client risk level\n    await supabase\n      .from('clients')\n      .update({ risk_level: validatedData.risk_level })\n      .eq('id', validatedData.client_id)\n    \n    return NextResponse.json({ data }, { status: 201 })\n  } catch (error) {\n    if (error instanceof Error && error.name === 'ZodError') {\n      return NextResponse.json(\n        { error: 'Validation error', details: (error as any).errors },\n        { status: 400 }\n      )\n    }\n    \n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}"