import { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@/lib/supabase/server'\nimport { authServer } from '@/lib/auth'\nimport { invoiceUpdateSchema } from '@/lib/validations/financial'\nimport { financialUtils } from '@/lib/financial-utils'\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    // Require permission to view invoices\n    const user = await authServer.requireRole(['admin', 'finance', 'operations', 'compliance'])\n    \n    const supabase = createClient()\n    \n    const { data, error } = await supabase\n      .from('invoices')\n      .select(`\n        *,\n        client:clients(*),\n        skr:skrs(\n          id,\n          skr_number,\n          status,\n          asset:assets(id, asset_name, asset_type)\n        ),\n        receipts:receipts(*),\n        credit_notes:credit_notes(*)\n      `)\n      .eq('id', params.id)\n      .single()\n    \n    if (error) {\n      if (error.code === 'PGRST116') {\n        return NextResponse.json({ error: 'Invoice not found' }, { status: 404 })\n      }\n      return NextResponse.json({ error: error.message }, { status: 400 })\n    }\n    \n    return NextResponse.json({ data })\n  } catch (error) {\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function PUT(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    // Require permission to manage invoices\n    const user = await authServer.requireRole(['admin', 'finance'])\n    \n    const body = await request.json()\n    \n    // Validate request body\n    const validatedData = invoiceUpdateSchema.parse(body)\n    \n    const supabase = createClient()\n    \n    // Get current invoice to validate status transitions\n    const { data: currentInvoice, error: fetchError } = await supabase\n      .from('invoices')\n      .select('*')\n      .eq('id', params.id)\n      .single()\n    \n    if (fetchError || !currentInvoice) {\n      return NextResponse.json({ error: 'Invoice not found' }, { status: 404 })\n    }\n    \n    // Validate status transition if status is being updated\n    if (validatedData.status && validatedData.status !== currentInvoice.status) {\n      if (!financialUtils.canTransitionInvoiceStatus(currentInvoice.status, validatedData.status)) {\n        return NextResponse.json(\n          { error: `Cannot transition from ${currentInvoice.status} to ${validatedData.status}` },\n          { status: 400 }\n        )\n      }\n    }\n    \n    // Prevent editing of paid or cancelled invoices (except status)\n    if (['paid', 'cancelled'].includes(currentInvoice.status)) {\n      const allowedFields = ['status', 'notes', 'metadata']\n      const updateFields = Object.keys(validatedData)\n      const restrictedFields = updateFields.filter(field => !allowedFields.includes(field))\n      \n      if (restrictedFields.length > 0) {\n        return NextResponse.json(\n          { error: `Cannot modify ${restrictedFields.join(', ')} - invoice is ${currentInvoice.status}` },\n          { status: 400 }\n        )\n      }\n    }\n    \n    // Recalculate totals if items are updated\n    let updateData = { ...validatedData }\n    if (validatedData.items) {\n      const itemErrors = financialUtils.validateInvoiceItems(validatedData.items)\n      if (itemErrors.length > 0) {\n        return NextResponse.json({ error: 'Invalid items', details: itemErrors }, { status: 400 })\n      }\n      \n      const subtotal = financialUtils.calculateSubtotal(validatedData.items)\n      const taxRate = validatedData.tax_rate ?? currentInvoice.tax_rate\n      const discountAmount = validatedData.discount_amount ?? currentInvoice.discount_amount\n      const taxAmount = financialUtils.calculateTaxAmount(subtotal, taxRate)\n      const total = financialUtils.calculateInvoiceTotal(validatedData.items, taxRate, discountAmount)\n      \n      updateData = {\n        ...updateData,\n        subtotal,\n        tax_amount: taxAmount,\n        amount: total\n      }\n    }\n    \n    const { data, error } = await supabase\n      .from('invoices')\n      .update({\n        ...updateData,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', params.id)\n      .select(`\n        *,\n        client:clients(*),\n        skr:skrs(\n          id,\n          skr_number,\n          asset:assets(id, asset_name)\n        ),\n        receipts:receipts(*)\n      `)\n      .single()\n    \n    if (error) {\n      return NextResponse.json({ error: error.message }, { status: 400 })\n    }\n    \n    return NextResponse.json({ data })\n  } catch (error) {\n    if (error instanceof Error && error.name === 'ZodError') {\n      return NextResponse.json(\n        { error: 'Validation error', details: (error as any).errors },\n        { status: 400 }\n      )\n    }\n    \n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    // Require admin permission to delete invoices\n    const user = await authServer.requireRole(['admin'])\n    \n    const supabase = createClient()\n    \n    // Check if invoice can be deleted (only drafts should be deletable)\n    const { data: invoice, error: fetchError } = await supabase\n      .from('invoices')\n      .select('status, receipts(id), credit_notes(id)')\n      .eq('id', params.id)\n      .single()\n    \n    if (fetchError || !invoice) {\n      return NextResponse.json({ error: 'Invoice not found' }, { status: 404 })\n    }\n    \n    if (invoice.status !== 'draft') {\n      return NextResponse.json(\n        { error: 'Only draft invoices can be deleted' },\n        { status: 400 }\n      )\n    }\n    \n    if (invoice.receipts && invoice.receipts.length > 0) {\n      return NextResponse.json(\n        { error: 'Cannot delete invoice with associated receipts' },\n        { status: 400 }\n      )\n    }\n    \n    if (invoice.credit_notes && invoice.credit_notes.length > 0) {\n      return NextResponse.json(\n        { error: 'Cannot delete invoice with associated credit notes' },\n        { status: 400 }\n      )\n    }\n    \n    const { error } = await supabase\n      .from('invoices')\n      .delete()\n      .eq('id', params.id)\n    \n    if (error) {\n      return NextResponse.json({ error: error.message }, { status: 400 })\n    }\n    \n    return NextResponse.json({ message: 'Invoice deleted successfully' })\n  } catch (error) {\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}"