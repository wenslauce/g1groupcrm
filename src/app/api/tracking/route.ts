import { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@/lib/supabase/server'\nimport { authServer } from '@/lib/auth'\nimport { trackingRecordSchema, trackingFiltersSchema } from '@/lib/validations/tracking'\nimport { trackingUtils } from '@/lib/tracking-utils'\n\nexport async function GET(request: NextRequest) {\n  try {\n    // Require permission to view tracking data\n    const user = await authServer.requireRole(['admin', 'finance', 'operations', 'compliance'])\n    \n    const supabase = createClient()\n    const { searchParams } = new URL(request.url)\n    \n    // Parse and validate filters\n    const filters = trackingFiltersSchema.parse({\n      skr_id: searchParams.get('skr_id') || undefined,\n      location: searchParams.get('location') || undefined,\n      status: searchParams.get('status') || undefined,\n      date_from: searchParams.get('date_from') || undefined,\n      date_to: searchParams.get('date_to') || undefined,\n      page: parseInt(searchParams.get('page') || '1'),\n      limit: parseInt(searchParams.get('limit') || '10')\n    })\n    \n    const offset = (filters.page - 1) * filters.limit\n    \n    let query = supabase\n      .from('tracking')\n      .select(`\n        *,\n        skr:skrs(\n          id,\n          skr_number,\n          status,\n          client:clients(id, name),\n          asset:assets(id, asset_name, asset_type)\n        ),\n        recorded_by_user:user_profiles!recorded_by(id, name)\n      `, { count: 'exact' })\n      .order('created_at', { ascending: false })\n    \n    // Apply filters\n    if (filters.skr_id) {\n      query = query.eq('skr_id', filters.skr_id)\n    }\n    \n    if (filters.location) {\n      query = query.ilike('location', `%${filters.location}%`)\n    }\n    \n    if (filters.status) {\n      query = query.eq('status', filters.status)\n    }\n    \n    if (filters.date_from) {\n      query = query.gte('created_at', filters.date_from)\n    }\n    \n    if (filters.date_to) {\n      query = query.lte('created_at', filters.date_to)\n    }\n    \n    const { data, error, count } = await query\n      .range(offset, offset + filters.limit - 1)\n    \n    if (error) {\n      return NextResponse.json({ error: error.message }, { status: 400 })\n    }\n    \n    return NextResponse.json({\n      data,\n      count,\n      page: filters.page,\n      limit: filters.limit,\n      total_pages: Math.ceil((count || 0) / filters.limit)\n    })\n  } catch (error) {\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Require permission to create tracking records\n    const user = await authServer.requireRole(['admin', 'finance', 'operations'])\n    \n    const body = await request.json()\n    \n    // Validate request body\n    const validatedData = trackingRecordSchema.parse({\n      ...body,\n      recorded_by: user.id\n    })\n    \n    const supabase = createClient()\n    \n    // Verify SKR exists and is accessible\n    const { data: skr, error: skrError } = await supabase\n      .from('skrs')\n      .select('id, skr_number, status')\n      .eq('id', validatedData.skr_id)\n      .single()\n    \n    if (skrError || !skr) {\n      return NextResponse.json({ error: 'SKR not found or not accessible' }, { status: 400 })\n    }\n    \n    // Validate coordinates if provided\n    if (validatedData.latitude !== undefined && validatedData.longitude !== undefined) {\n      if (!trackingUtils.validateCoordinates(validatedData.latitude, validatedData.longitude)) {\n        return NextResponse.json({ error: 'Invalid coordinates provided' }, { status: 400 })\n      }\n    }\n    \n    // Create tracking record\n    const { data, error } = await supabase\n      .from('tracking')\n      .insert({\n        skr_id: validatedData.skr_id,\n        location: validatedData.location,\n        latitude: validatedData.latitude,\n        longitude: validatedData.longitude,\n        status: validatedData.status,\n        notes: validatedData.notes,\n        recorded_by: validatedData.recorded_by,\n        metadata: validatedData.metadata || {}\n      })\n      .select(`\n        *,\n        skr:skrs(\n          id,\n          skr_number,\n          status,\n          client:clients(id, name),\n          asset:assets(id, asset_name)\n        ),\n        recorded_by_user:user_profiles!recorded_by(id, name)\n      `)\n      .single()\n    \n    if (error) {\n      return NextResponse.json({ error: error.message }, { status: 400 })\n    }\n    \n    return NextResponse.json({ data }, { status: 201 })\n  } catch (error) {\n    if (error instanceof Error && error.name === 'ZodError') {\n      return NextResponse.json(\n        { error: 'Validation error', details: (error as any).errors },\n        { status: 400 }\n      )\n    }\n    \n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}"